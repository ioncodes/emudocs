{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>I post my emudev notes here...</p>"},{"location":"PSX/BIOS/","title":"BIOS","text":"<p>random PSX notes using <code>SCPH1000.BIN</code> and <code>SCPH1001.BIN</code></p>"},{"location":"PSX/BIOS/#getting-to-shell","title":"Getting to Shell","text":"<p>In my testing a few things are required to be able to progress to the BIOS shell:</p> <ul> <li>Being at the diamond screen (duh...)</li> <li>Timer or at least forcing <code>0xFF</code> on reads</li> <li>VBLANK IRQ (kind of... without it I get stuck in a blue screen)</li> <li>CDROM with a few basic commands and IRQ</li> </ul> <p>Note: unmapped reads return <code>0xFF</code> for me!! Depending on that value results may differ.</p>"},{"location":"PSX/BIOS/#cdrom-commands","title":"CDROM Commands","text":"<p>The following commands seem to be required as a bare minimum:</p> <pre><code>cmd     subcmd  irq     result fifo\n----------------------------------------------\n0x01            INT3    Status\n0x19    0x20    INT3    Get cdrom BIOS date/version (yy,mm,dd,ver)\n</code></pre>"},{"location":"PSX/BIOS/#further-notes-code","title":"Further Notes &amp; Code","text":"<ul> <li>I return <code>[0x69, 0x69, 0x69, 0x69]</code> for the CDROM version</li> <li>I set only the \"Shell Open\" bit for status</li> <li>I send both \"acknowledge\" and \"complete\" IRQs (with an arbitrary 1000 cycle delay inbetween)</li> <li>I update parameter readiness bits on every tick</li> </ul> <pre><code>fn execute_command(&amp;mut self, command: u8) {\n    match command {\n        // 0x01     Nop         INT3: status\n        0x01 =&gt; {\n            self.pending_command = Some(command);\n            self.send_status(&amp;[]);\n            self.trigger_irq(DiskIrq::CommandAcknowledged);\n        }\n        // 0x19     Test *  sub, ...    INT3: ...\n        0x19 =&gt; {\n            let subcommand = self.parameter_fifo.pop_front().unwrap();\n            self.execute_subcommand(subcommand);\n        }\n        _ =&gt; {\n            tracing::error!(\n                target: \"psx_core::cdrom\",\n                command = format!(\"{:02X}\", command),\n                \"Unimplemented CDROM command\",\n            );\n        }\n    }\n\n    self.address.set_busy_status(true);\n}\n\nfn execute_subcommand(&amp;mut self, subcommand: u8) {\n    match subcommand {\n        0x20 =&gt; {\n            self.result_fifo.push_back(0x69); // year\n            self.result_fifo.push_back(0x69); // month\n            self.result_fifo.push_back(0x69); // day\n            self.result_fifo.push_back(0x69); // version\n            self.trigger_irq(DiskIrq::CommandAcknowledged);\n        }\n    }\n}\n\npub fn tick(&amp;mut self, cycles: usize) {\n    self.address.set_parameter_empty(self.parameter_fifo.is_empty());\n    self.address.set_parameter_write_ready(self.parameter_fifo.len() &lt; 16);\n    self.cycles += cycles;\n\n    if self.cycles &gt;= CYCLE_DELAY {\n        self.cycles -= CYCLE_DELAY;\n\n        if let Some(command) = self.pending_command.take() {\n            self.parameter_fifo.clear();\n            self.address.set_busy_status(false);\n            self.address.set_data_request(true);\n            self.address.set_result_read_ready(true);\n\n            self.trigger_irq(DiskIrq::CommandCompleted);\n        }\n    }\n}\n</code></pre> <p>My TTY logs (VSync timeouts omitted):</p> <pre><code>INFO psx_core::tty:\nINFO psx_core::tty: PS-X Realtime Kernel Ver.2.5\nINFO psx_core::tty: Copyright 1993,1994 (C) Sony Computer Entertainment Inc.\nINFO psx_core::tty: KERNEL SETUP!\nINFO psx_core::tty:\nINFO psx_core::tty: Configuration : EvCB       0x10            TCB     0x04\nINFO psx_core::tty: System ROM Version 2.2 12/04/95 A\nINFO psx_core::tty: Copyright 1993,1994,1995 (C) Sony Computer Entertainment Inc.\nINFO psx_core::tty: ResetCallback: _96_remove ..\nINFO psx_core::tty: System Controller ROM Version 69/69/69 69\nINFO psx_core::tty: PS-X Control PAD Driver  Ver 3.0\n</code></pre>"},{"location":"PSX/BIOS/#bios-stuck-in-loop","title":"BIOS Stuck in Loop","text":"<p>Stubbed <code>GPUSTAT</code> (<code>0xFFFF_FFFF</code>) will eventually lead to this:</p> <pre><code>loc_8004FE44:\nlw      $a4, 0($a1)\naddiu   $v1, $v1, 1\nxor     $a5, $v0, $a4\nand     $a6, $a5, $a0\nbeq     $a6, $zero, loc_8004FE44\nnop\n</code></pre> <p>where:</p> <ul> <li><code>a0</code> is <code>0x8000_0000</code></li> <li><code>a1</code> points to <code>GPUSTAT</code> register</li> <li><code>v0</code> is original <code>GPUSTAT</code> value</li> </ul> <p>Basically waits for bit 31 to change.</p> <p>In 480-lines mode, bit31 changes per frame. And in 240-lines mode, the bit changes per scanline. The bit is always zero during Vblank (vertical retrace and upper/lower screen border).</p> <p>Seems to be 240-lines mode in my case. We get here because of the start of that routine:</p> <pre><code>sub_8004FE08:\nlw      $v0, 0($a1)\nbne     $a0, $zero, loc_8004FF00\nlui     $at, 8\nand     $t6, $v0, $at\nbeq     $t6, $zero, loc_8004FE64\nnop\n</code></pre> <p>Roughly translates to (same register meaning as above): <pre><code>if ( (*GPUSTAT &amp; 0x80000) != 0 ) {\n  // Deadlock here...\n}\n</code></pre></p> <p>It checks bit 19, if it's not 0 it will start waiting for something. This bit indicates vertical resolution:</p> <ul> <li>0 = 240 lines (what it should be according to my emulator atm)</li> <li>1 = 480 lines</li> </ul> <p>So if the vertical resolution is 480 lines it will start waiting for a new frame presumably? Since the next bit change (bit 31) would be during VBLANK (???). Since <code>GPUSTAT</code> is stubbed it will always think we are in 480 lines mode. <code>0x1480_2000</code> seems to work better as an early stub (reset value?) but breaks the amidog CPU tests unless bit 27 which indicates VRAM to CPU DMA readiness is forcefully set as well.</p> <p>Note: BIOS does swap to 480-lines mode eventually, so can't really escape it for long.</p>"},{"location":"PSX/GPU/","title":"GPU","text":""},{"location":"PSX/GPU/#background-polygon-missing","title":"Background Polygon Missing","text":"<p>The Japanese BIOS versions (? need to verify this pattern) seem to get the background wrong (for example <code>SCPH1000.BIN</code> and <code>SCPH3000.BIN</code>. No idea why, noticed this at Git commit <code>12a9d2716ceff315957238c8590fbffd31c52db9</code>. Other BIOS versions like <code>SCPH1001.BIN</code> work fine.</p>"},{"location":"PSX/GPU/#calculating-polygon-word-count","title":"Calculating Polygon Word Count","text":"<p>Polygon primitive base count is calculated based on vertices count bit:</p> <pre><code>pub struct DrawPolygonCommand(pub u32) {\n    pub color: u32 @ 0..=23,\n    pub raw_texture: bool @ 24,\n    pub semi_transparent: bool @ 25,\n    pub textured: bool @ 26,\n    pub vertices_count: bool @ 27,\n    pub gouraud: bool @ 28,\n    pub command: u32 @ 29..=31,\n}\n</code></pre> <p>Base count of extra data words is either 4 or 3 (will call the count <code>vertices</code>). 4 if <code>vertices_count</code> is set.</p> <ul> <li>If <code>gouraud</code> is set, then <code>vertices - 1</code> on top of that</li> <li>If <code>textured</code> is set, then <code>vertices</code></li> </ul> <p>Basically: <pre><code>Gp0Command::PolygonPrimitive(cmd) =&gt; {\n    let vertices = if cmd.vertices_count() { 4 } else { 3 };\n    let mut base = vertices;\n\n    // requires color for vertices 1..n (color 0 in cmd word)\n    if cmd.gouraud() {\n        base += vertices - 1;\n    }\n\n    // requires UV for each vertex (no vertex in cmd word)\n    if cmd.textured() {\n        base += vertices;\n    }\n\n    base\n}\n</code></pre></p>"},{"location":"PSX/GPU/#rasterizer","title":"Rasterizer","text":"<p>Given vertices v0, v1, v2, v3 to draw a rectangle/quad: <pre><code>v0 --- v1        Triangle 1: v0 -&gt; v1 -&gt; v2\n|       |        Triangle 2: v1 -&gt; v2 -&gt; v3\n|       |\nv2 --- v3        Note: 0-indexed, see below\n</code></pre></p> <p>Quads are internally processed as two triangles, the first consisting of vertices 1,2,3, and the second of vertices 2,3,4. Source</p> <pre><code>fn rasterize_polygon(vertices: &amp;[(i16, i16)], colors: &amp;[u32], vram: &amp;mut [u8]) {\n    // fun stuff\n}\n</code></pre> <ul> <li>If <code>vertices.len() == 4</code> then we know we have a quad and must split it into 2 triangles</li> <li>If not, then we operate on \"Triangle 1\" only</li> <li><code>colors</code> maps each coordinate with a color which can later be used for coloring and applying gradient</li> <li><code>vram</code> is just a reference to the internal VRAM storage</li> </ul> <p>To get the coordinate/corner positions: <pre><code>let (x0, y0) = (vertices[0].0 as i32, vertices[0].1 as i32);\nlet (x1, y1) = (vertices[1].0 as i32, vertices[1].1 as i32);\nlet (x2, y2) = (vertices[2].0 as i32, vertices[2].1 as i32);\n</code></pre></p> <p>For optimization we can define a min/max (bounding box?) of the polygon so we can perform the math on this selection only: <pre><code>let min_x = x0.min(x1).min(x2).max(0);\nlet max_x = x0.max(x1).max(x2).min(VRAM_WIDTH as i32 - 1);\nlet min_y = y0.min(y1).min(y2).max(0);\nlet max_y = y0.max(y1).max(y2).min(VRAM_HEIGHT as i32 - 1);\n</code></pre></p> <ul> <li><code>min_x</code>: The leftmost point of any corner</li> <li><code>max_x</code>: The rightmost point of any corner</li> <li><code>min_y</code>: The topmost point of any corner</li> <li><code>max_y</code>: The bottommost point of any corner</li> </ul> <p>Now to fill a triangle we'll have to go through each point in the bounding box (?) and check whether this point is:</p> <ul> <li>to the left of a line A to B</li> <li>to the right of a line A to B</li> <li>on top of a line A to B</li> </ul> <pre><code>fn edge_function(ax: i32, ay: i32, bx: i32, by: i32, px: i32, py: i32) -&gt; i32 {\n    (bx - ax) * (py - ay) - (by - ay) * (px - ax)\n}\n\nlet area = edge_function(x0, y0, x1, y1, x2, y2); // if area == 0 -&gt; straight line\nlet clockwise = area &lt; 0;\n\nlet w0 = edge_function(x1, y1, x2, y2, x, y);\nlet w1 = edge_function(x2, y2, x0, y0, x, y);\nlet w2 = edge_function(x0, y0, x1, y1, x, y);\n\nlet inside = if clockwise {\n    w0 &lt;= 0 &amp;&amp; w1 &lt;= 0 &amp;&amp; w2 &lt;= 0\n} else {\n    w0 &gt;= 0 &amp;&amp; w1 &gt;= 0 &amp;&amp; w2 &gt;= 0\n};\n\n// if inside == true -&gt; pixel x,y is inside of triangle\n</code></pre> <p>To interpolate the colors: <pre><code>let r0 = (colors[0] &amp; 0xFF) as i32;\nlet g0 = ((colors[0] &gt;&gt; 8) &amp; 0xFF) as i32;\nlet b0 = ((colors[0] &gt;&gt; 16) &amp; 0xFF) as i32;\n\nlet r1 = (colors[1] &amp; 0xFF) as i32;\nlet g1 = ((colors[1] &gt;&gt; 8) &amp; 0xFF) as i32;\nlet b1 = ((colors[1] &gt;&gt; 16) &amp; 0xFF) as i32;\n\nlet r2 = (colors[2] &amp; 0xFF) as i32;\nlet g2 = ((colors[2] &gt;&gt; 8) &amp; 0xFF) as i32;\nlet b2 = ((colors[2] &gt;&gt; 16) &amp; 0xFF) as i32;\n\n// gouraud shading\nlet r = (r0 * w0 + r1 * w1 + r2 * w2) / area;\nlet g = (g0 * w0 + g1 * w1 + g2 * w2) / area;\nlet b = (b0 * w0 + b1 * w1 + b2 * w2) / area;\n</code></pre></p> <p>Since VRAM stores RGB values as RGB555 we'll have to modify them: <pre><code>let r5 = ((r &gt;&gt; 3) &amp; 0x1F) as u16;\nlet g5 = ((g &gt;&gt; 3) &amp; 0x1F) as u16;\nlet b5 = ((b &gt;&gt; 3) &amp; 0x1F) as u16;\nlet pixel = (b5 &lt;&lt; 10) | (g5 &lt;&lt; 5) | r5;\n</code></pre></p>"},{"location":"PSX/GPU/#half-textured-polygons","title":"Half Textured Polygons","text":"<pre><code>rasterize_polygon\n -&gt; rasterize_triangle\n</code></pre> <p>If <code>rasterize_triangle</code> extracts CLUT and Texpage from UVs then that won't work as uv0 is uv1 and uv1 is uv2. <pre><code>rasterize_triangle(\n    // ...\n    if textured {\n        [uvs[0], uvs[1], uvs[2]]\n    } else {\n        [0, 0, 0]\n    },\n    // ...\n);\nrasterize_triangle(\n    // ...\n    if textured {\n        [uvs[1], uvs[2], uvs[3]]\n    } else {\n        [0, 0, 0]\n    },\n    // ...\n);\n// Wont work!! need to get CLUT and Texpage before call rasterize_trinalgle since those are always inside uv0 and uv1\n</code></pre></p>"},{"location":"PSX/GPU/#missing-sony-logo-colors","title":"Missing Sony Logo Colors","text":"<p>In my case CLUT got overwritten!!</p> <p>Polygons are displayed up to \\ their lower-right coordinates. Source <p>Should be able to see them just below the grey area as white-ish dots. That disappears eventually. Bounding box needs to be exclusive.</p> <pre><code>let min_x = x0.min(x1).min(x2).max(0);\nlet max_x = x0.max(x1).max(x2).min(VRAM_WIDTH as i32);\nlet min_y = y0.min(y1).min(y2).max(0);\nlet max_y = y0.max(y1).max(y2).min(VRAM_HEIGHT as i32);\n\nfor y in min_y..max_y {\n    for x in min_x..max_x {\n        // rasterize\n    }\n}\n</code></pre> <p>Honorary mention: Chicho</p>"},{"location":"PSX/GPU/#rainbows-behind-balls","title":"Rainbows Behind Balls","text":"<p> This happens when the \"Quick Rectangle Fill\" GP0 command (Misc. Commands, subcommand <code>0x02</code>) is not implemented.</p>"},{"location":"PSX/GPU/#main-menu-grey-rectangle","title":"Main Menu Grey Rectangle","text":"<p>This happens when you only sample textures for polygons. (see above image)</p>"},{"location":"PSX/GPU/#missing-white-text-color","title":"Missing White Text Color","text":"<p>This happens when I return transparency if the texel index is 0 as opposed to the texel itself. (see above)</p> <p>Honorary mention: netcatto</p>"},{"location":"PSX/Games/","title":"Games","text":"<p>(mostly?) fixes for game issues</p>"},{"location":"PSX/Games/#puzzle-bobble-2","title":"Puzzle Bobble 2","text":""},{"location":"PSX/Games/#controller-input-issues","title":"Controller Input Issues","text":"<p>Directional controls (up/down) on this screen might not work (even though other buttons work). This happens if SIO0 RX is sent for both ports at the same time (bit 13).</p> <pre><code>0     TX Enable (TXEN)      (0=Disable, 1=Enable)\n1     DTR Output Level      (0=Off, 1=On)\n2     RX Enable (RXEN)      (SIO1: 0=Disable, 1=Enable)  ;Disable also clears RXFIFO\n                            (SIO0: 0=only receive when /CS low, 1=force receiving single byte)\n3     SIO1 TX Output Level  (0=Normal, 1=Inverted, during Inactivity &amp; Stop bits)\n4     Acknowledge           (0=No change, 1=Reset SIO_STAT.Bits 3,4,5,9)      (W)\n5     SIO1 RTS Output Level (0=Off, 1=On)\n6     Reset                 (0=No change, 1=Reset most registers to zero) (W)\n7     SIO1 unknown?         (read/write-able when FACTOR non-zero) (otherwise always zero)\n8-9   RX Interrupt Mode     (0..3 = IRQ when RX FIFO contains 1,2,4,8 bytes)\n10    TX Interrupt Enable   (0=Disable, 1=Enable) ;when SIO_STAT.0-or-2 ;Ready\n11    RX Interrupt Enable   (0=Disable, 1=Enable) ;when N bytes in RX FIFO\n12    DSR Interrupt Enable  (0=Disable, 1=Enable) ;when SIO_STAT.7  ;DSR high or /ACK low\n13    SIO0 port select      (0=port 1, 1=port 2) (/CS pulled low when bit 1 set)\n14-15 Not used              (always zero)\n</code></pre> <p>Based on bit 13 only respond for the selected port. In my case I ignore port 2 (returning <code>0xFF</code> denotes absence).</p> <pre><code>match tx_byte {\n    0x01 =&gt; {\n        if self.control.port_number() == 2 {\n            // If Port 2 is selected, no controller is present\n            tracing::trace!(\n                target: \"psx_core::sio\",\n                tx = format!(\"{:02X}\", tx_byte),\n                \"Port 2 selected - no device\"\n            );\n            return 0xFF;\n        }\n\n        self.active_device = ActiveDevice::Controller;\n    }\n    0x81 =&gt; {\n        self.active_device = ActiveDevice::MemoryCard;\n    }\n    _ =&gt; {}\n}\n</code></pre> <p>When SIO0_CTRL is written, I also check whether the port number changed to 2 and reset the state machine if necessary: <pre><code>if matches!(self.active_device, ActiveDevice::None | ActiveDevice::Controller)\n    &amp;&amp; self.control.port_number() == 2\n{\n    self.reset_devices();\n}\n</code></pre></p> <p>Honorary mention: Chicho</p>"},{"location":"PSX/Games/#mortal-kombat-ii","title":"Mortal Kombat II","text":""},{"location":"PSX/Games/#fragmented-graphics","title":"Fragmented Graphics","text":"<p>Polygon commands must propagate their texpage to the global texpage.</p> <pre><code>// Update global texpage state from polygon's embedded texpage\n// Texpage is in uvs[1] upper 16 bits (same location as for triangles/quads)\nif uvs.len() &gt; 1 {\n    let texpage = ((uvs[1] &gt;&gt; 16) &amp; 0xFFFF) as u16;\n\n    // Extract texpage components (bits 0-8, 11 update global state)\n    let texture_page_x_base = (texpage &amp; 0xF) as u32;\n    let texture_page_y_base_1 = ((texpage &gt;&gt; 4) &amp; 0x1) != 0;\n    let texture_page_colors = ((texpage &gt;&gt; 7) &amp; 0x3) as u32;\n    let texture_page_y_base_2 = ((texpage &gt;&gt; 11) &amp; 0x1) != 0;\n\n    // Update global GPU state (same as GP0(E1h) command)\n    self.gp.gp1_status.set_texture_page_x_base(texture_page_x_base);\n    self.gp.gp1_status.set_texture_page_y_base_1(texture_page_y_base_1);\n    self.gp.gp1_status.set_texture_page_colors(texture_page_colors);\n    self.gp.gp1_status.set_texture_page_y_base_2(texture_page_y_base_2);\n}\n</code></pre> <p>Honorary mention: Lycoder</p>"},{"location":"PSX/Games/#missing-graphics","title":"Missing Graphics","text":"<p>Missing VRAM to VRAM Blit command, something along the lines of:</p> <pre><code>let src_x = (parsed_cmd.data[0] &amp; 0xFFFF) as u16;\nlet src_y = ((parsed_cmd.data[0] &gt;&gt; 16) &amp; 0xFFFF) as u16;\nlet dst_x = (parsed_cmd.data[1] &amp; 0xFFFF) as u16;\nlet dst_y = ((parsed_cmd.data[1] &gt;&gt; 16) &amp; 0xFFFF) as u16;\nlet width = (parsed_cmd.data[2] &amp; 0xFFFF) as usize;\nlet height = ((parsed_cmd.data[2] &gt;&gt; 16) &amp; 0xFFFF) as usize;\n\n// Copy rectangle from source to destination in VRAM\n// Handle overlapping regions by copying to a temporary buffer first\nlet mut temp_buffer: Vec&lt;u16&gt; = Vec::with_capacity(width * height);\n\n// Read from source\nfor row in 0..height {\n    for col in 0..width {\n        let vram_x = (src_x as usize + col) &amp; (VRAM_WIDTH - 1);\n        let vram_y = (src_y as usize + row) &amp; (VRAM_HEIGHT - 1);\n        let vram_idx = (vram_y * VRAM_WIDTH + vram_x) * 2;\n        let byte0 = self.gp.vram[vram_idx];\n        let byte1 = self.gp.vram[vram_idx + 1];\n        let pixel = u16::from_le_bytes([byte0, byte1]);\n        temp_buffer.push(pixel);\n    }\n}\n\n// Write to destination\nlet mut pixel_idx = 0;\nfor row in 0..height {\n    for col in 0..width {\n        let vram_x = (dst_x as usize + col) &amp; (VRAM_WIDTH - 1);\n        let vram_y = (dst_y as usize + row) &amp; (VRAM_HEIGHT - 1);\n        let vram_idx = (vram_y * VRAM_WIDTH + vram_x) * 2;\n        let bytes = temp_buffer[pixel_idx].to_le_bytes();\n        self.gp.vram[vram_idx] = bytes[0];\n        self.gp.vram[vram_idx + 1] = bytes[1];\n        pixel_idx += 1;\n    }\n}\n</code></pre>"}]}